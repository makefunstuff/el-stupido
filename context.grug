# el-stupido project manifest
# ğŸ“‚ mem values are shell commands â€” run one for on-demand context

ğŸ“‚ project
ğŸ”‘ name ğŸ‘‰ el-stupido
ğŸ”‘ desc ğŸ‘‰ decision-manifest compiler: LLMs emit decisions, compiler does the rest
ğŸ”‘ bin ğŸ‘‰ esc
ğŸ”‘ ext ğŸ‘‰ .es
ğŸ”‘ build ğŸ‘‰ make
ğŸ”‘ run ğŸ‘‰ ./esc input.es -o out [-O2] [--wasm]

ğŸ“‚ manifest
ğŸ”‘ core ğŸ‘‰ LLMs emit 30-80 tokens of JSON decisions, compiler expands deterministically
ğŸ”‘ compile ğŸ‘‰ ./esc --manifest app.json -o app â€” JSON manifest -> native binary
ğŸ”‘ expand ğŸ‘‰ ./esc --manifest-expand app.json â€” print expanded el-stupido source
ğŸ”‘ grammar ğŸ‘‰ ./esc --manifest-grammar â€” print GBNF grammar for constrained LLM output
ğŸ”‘ generate ğŸ‘‰ ./esc --generate prompt.txt --llm model.gguf -o app (needs LLAMA=1)
ğŸ”‘ domains ğŸ‘‰ crud (CRUD web app), rest (JSON API), cli (CLI tool), test (test runner)
ğŸ”‘ schema ğŸ‘‰ spec/manifest.json â€” JSON schema for decision manifests
ğŸ”‘ src ğŸ‘‰ src/manifest.h src/manifest.c â€” parser, expander, GBNF grammar
ğŸ”‘ ratios ğŸ‘‰ crud 17x, rest 14x, wardrobe 14x (from JSON manifest to el-stupido source)

ğŸ“‚ lang
ğŸ”‘ pipeline ğŸ‘‰ lexer -> parser -> AST -> LLVM codegen -> cc link (or wasm-ld for --wasm)
ğŸ”‘ features ğŸ‘‰ emoji kw/types/stdlib, structs, ptrs, UFCS, âœ¨/ğŸ—‘ mem, âš¡comptime, ğŸ”©asm, ğŸ“macros
ğŸ”‘ new_features ğŸ‘‰ â°for, ğŸ¯match, ğŸ·enum, ğŸ”œdefer, fn ptrs, struct init âœ¨T{}, short-circuit &&/||
ğŸ”‘ std ğŸ‘‰ lib/std.es auto-loaded, no import needed
ğŸ”‘ llvm ğŸ‘‰ opaque ptrs: Load2/GEP2/Call2 need explicit type, PointerType(ctx,0)
ğŸ”‘ short_circuit ğŸ‘‰ && and || are short-circuit (phi nodes), safe for null guards
ğŸ”‘ macros ğŸ‘‰ âš¡ NAME(p) ğŸ‘‰ body â€” unified with comptime, ğŸ‘‰ = macro def, no ğŸ‘‰ = eval
ğŸ”‘ kw_fixed ğŸ‘‰ v/st/sz removed as ASCII keywords â€” use â¬›/ğŸ“¦/ğŸ“ emoji versions
ğŸ”‘ unsigned ğŸ‘‰ ğŸ”µ(u32)/ğŸ’(u64) now use UDiv/URem/LShr/unsigned comparisons
ğŸ”‘ ptr_diff ğŸ‘‰ ptr - ptr yields i64 integer via ptrtoint subtraction

ğŸ“‚ syntax_quick
ğŸ”‘ for_loop ğŸ‘‰ â° i := 0..10 { body }
ğŸ”‘ match ğŸ‘‰ ğŸ¯ expr { val { body } _ { default } }
ğŸ”‘ enum ğŸ‘‰ ğŸ· Name { A; B; C=5; D }
ğŸ”‘ struct_init ğŸ‘‰ p := âœ¨ T { field: val, ... }
ğŸ”‘ fn_ptr_type ğŸ‘‰ *ğŸ”§(ğŸ”¢,ğŸ”¢)->ğŸ”¢
ğŸ”‘ defer ğŸ‘‰ ğŸ”œ stmt â€” runs in reverse at function return
ğŸ”‘ import ğŸ‘‰ ğŸ“¥ name â€” loads lib/<name>.es

ğŸ“‚ preludes
ğŸ”‘ std ğŸ‘‰ lib/std.es â€” libc externs (printf,malloc,socket,fork,math,...) auto-loaded
ğŸ”‘ grug ğŸ‘‰ lib/grug.es â€” .grug CRUD (parse/query/mutate/write/free), ~120 LOC
ğŸ”‘ str ğŸ‘‰ lib/str.es â€” string builder: str_new/str_add/str_addc/str_fmt/str_get/str_len/str_clear/str_fr
ğŸ”‘ vec ğŸ‘‰ lib/vec.es â€” dynamic array (void* elems): vec_new/vec_push/vec_get/vec_pop/vec_len/vec_fr
ğŸ”‘ map ğŸ‘‰ lib/map.es â€” string->string hashmap: map_new/map_set/map_get/map_del/map_len/map_fr
ğŸ”‘ http ğŸ‘‰ lib/http.es â€” HTTP server: http_listen/http_resp/http_send/http_path/http_fval/http_hesc/http_udec
ğŸ”‘ ws ğŸ‘‰ lib/ws.es â€” WebSocket server (RFC 6455): sha1/b64_enc/ws_handshake/ws_read/ws_send/ws_text/ws_close
ğŸ”‘ gl ğŸ‘‰ lib/gl.es â€” WebGL bridge imports for WASM: gl_clear/gl_rect/js_random
ğŸ”‘ wasm ğŸ‘‰ lib/wasm.es â€” WASM freestanding helpers: walloc/wstrlen/wstrcpy/wmemcpy/itoa_buf

ğŸ“‚ mem
ğŸ”‘ emoji_kw ğŸ‘‰ sed -n '/^static TokenKind check_emoji/,/^}/p' src/lexer.c
ğŸ”‘ emoji_fn ğŸ‘‰ sed -n '/^static const char \*check_emoji_fn/,/^}/p' src/lexer.c
ğŸ”‘ tokens ğŸ‘‰ grep TOK_ src/lexer.h
ğŸ”‘ ast ğŸ‘‰ grep -E 'ND_|ES_TY' src/ast.h
ğŸ”‘ syntax ğŸ‘‰ cat spec/grammar.peg
ğŸ”‘ std ğŸ‘‰ cat lib/std.es
ğŸ”‘ examples ğŸ‘‰ ls examples/ && ls tools/
ğŸ”‘ grugmem ğŸ‘‰ grugmem dump
ğŸ”‘ manifest ğŸ‘‰ cat spec/manifest.json

ğŸ“‚ codebooks
ğŸ”‘ web ğŸ‘‰ use web â€” HTTP/WS server: listen/route/ws/crud/tpl/save (3-6 lines -> 400+ lines)
ğŸ”‘ cli ğŸ‘‰ use cli â€” CLI arg parser: name/desc/flag/arg -> struct Cli + main + help (7 lines -> 50 lines)
ğŸ”‘ rest ğŸ‘‰ use rest â€” JSON REST API: model/GET/POST -> HTTP+JSON+grug persistence (6 lines -> 120 lines)
ğŸ”‘ test ğŸ‘‰ use test â€” test runner: test "name" { assert EXPR } -> ANSI pass/fail (4 lines -> 60 lines)

ğŸ“‚ tools
ğŸ”‘ grugmem ğŸ‘‰ KV store CLI (~33 LOC, uses ğŸ“¥ grug)
ğŸ”‘ gruweb ğŸ‘‰ .grug â†’ HTML+CSS+JS transpiler (~81 LOC, uses ğŸ“¥ grug)
ğŸ”‘ grugbook ğŸ‘‰ guestbook web app: fork-per-conn HTTP, .grug persistence (~100 LOC, uses ğŸ“¥ grug)
ğŸ”‘ snake ğŸ‘‰ WebGL snake game: WASM game logic + native HTTP server (~100+40 LOC)

ğŸ“‚ llm
ğŸ”‘ build ğŸ‘‰ make LLAMA=1 â€” links llama.cpp, adds --llm and --generate flags (~5MB binary)
ğŸ”‘ old_usage ğŸ‘‰ ./esc --llm model.gguf input.txt -o out â€” LLM generates codebook from input
ğŸ”‘ new_usage ğŸ‘‰ ./esc --generate prompt.txt --llm model.gguf -o app â€” LLM -> manifest -> compile
ğŸ”‘ flags ğŸ‘‰ --llm <path> --llm-raw --llm-grammar --generate <prompt>
ğŸ”‘ grammar ğŸ‘‰ GBNF constrains LLM to valid manifest JSON (30-80 tokens)
ğŸ”‘ src ğŸ‘‰ src/llm.c src/llm.h â€” wraps llama.cpp C API (load/generate/free)
ğŸ”‘ dep ğŸ‘‰ deps/llama.cpp (git submodule) â€” static libs, CPU-only, no GPU needed
ğŸ”‘ pipeline ğŸ‘‰ prompt -> LLM (GBNF constrained) -> JSON manifest -> expand -> compile

ğŸ“‚ wasm
ğŸ”‘ compile ğŸ‘‰ ./esc prog.es --wasm -o prog.wasm (skips std.es, uses wasm-ld)
ğŸ”‘ no_std ğŸ‘‰ --wasm skips auto-loading lib/std.es (libc not available in WASM)
ğŸ”‘ imports ğŸ‘‰ ğŸ”Œ extern decls become WASM imports (JS provides via env object)
ğŸ”‘ exports ğŸ‘‰ all ğŸ”§ functions exported, callable from JS
ğŸ”‘ memory ğŸ‘‰ linear memory exported, 1MB initial, 16MB max
ğŸ”‘ freestanding ğŸ‘‰ no libc â€” use lib/gl.es or lib/wasm.es for helpers
