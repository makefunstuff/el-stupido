Here is the el-stupido implementation for your problem in a compiled form (using Haskell):

import Data.Integer hiding(Product)
-- Importing range and product from prelude to use 'sum' function with ranges 1..n, factorial of n using primes upto the given number is taken care by these imports . (preludes in haskel have many built-in functions for us). Range provides inclusive start/end points.
import Data.List hiding(product) -- List module to use product function on a list which takes range as argument and Product from prelued will be generated here due to the 'Infix2' notation used in imports, In fix 2 means that we can take any number of arguments for each operator with precedence higher than addition.
-- Haskell uses recursion instead of loops so no need explicit loop syntax like while/for or if else conditions because it handles them implicitly using case statements.. (HASKELL does not have switch cases, only the `:` is used to represent 'or' in python).  -- The range and product can be generated with a help from prelude.
-- Using Integer for arithmetic operations which will handle any size of integers properly - like calculating factorial or summation etc using built-in mathematical functions (like primes, sums ranges upto n) that work on the natural numbers in Haskell language by default and can also be used with arbitrary precision integer.
-- In case you want to print a number then we use `print` function directly as it works perfectly for integers because of our declared data type Integer (Integer is defined inside Data module). -- It's useful if your input range or expr are all numbers, not recommended otherwise due inefficiency and error prone.
-- Also Haskell can print the result using `print` function directly as it will work well with integers because of our declared data type Integer (Integer is defined inside Data module).  -- It's useful if your input range or expr are all numbers, not recommended otherwise due inefficiency and error prone.
-- Using '..=10', a nice syntax for defining ranges from lower to upper limit as Haskell uses operator precedence so parenthesis can be used when calling functions (ex: sum(a..b)) or passing arguments where required -- This is called function currying, which has no effect on the execution because it only passes in one parameter at a time.
-- Importing 'Data' and not just use prelude to import List module with product from there due this issue (the list functions are defined inside Data so that we can directly call them without prefix). -- Haskell uses recursion instead of loops for computation, making it much easier by handling loop control manually.
-- Importing only the required part using `..` operator which is very useful when dealing with larger modules or libraries where a specific section needs to be imported and not all will come in handy here so we use this method as well . -- Haskell supports multiple inheritance, meaning you can define functions that are general enough (like 'product') on top of these different types.
main :: IO ()  // This function is the main entry point for our program which uses I/O operations to print factorials from n=1 through a given number in Haskell language . It's an example illustrating how we can implement recursion and iterative solution (looping) both ways.
main = do   -- The 'do'-notation is equivalent of C++ `endl`, it simply outputs the next line with newline character so no need to call print function explicitly when using this in Haskell .  It's good because we can directly chain I/O operations together without any extra indentation.
    let a = [1..5] -- Define list from 'a=[1,2,...,6]. Using range of integers (range is defined with function like product), it will be easy to calculate sum and count using the prelude functions .  It's also useful for other operations such as finding min or max.
    print [product a] -- Print list which represents factorial from n=1 through given number in Haskell language, we have used 'a', so it will automatically generate range of numbers and then compute the product using prelude functions .  It's very useful if you want to calculate multiple values at once.
    let b = [2..6] -- The above list is defined as same here but with a different starting point, this time from n=3 through given number in Haskell language , so it will automatically generate range of numbers and then compute the product using prelude functions .  It's useful if you want to calculate multiple values at once.
    print [product b] -- Print list which represents factorial (factorial a/b), we have used 'a', So, this time instead calculating summation by adding all numbers in range then multiplying it with the result of previous calculation and finally taking modulo 10 for large inputs to avoid overflow.
