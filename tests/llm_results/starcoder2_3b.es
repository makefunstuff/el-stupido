
"""
import ast
import os
import sys
import traceback
from functools import reduce


class CompilerError(Exception):
    """An error that occurs during compilation."""

    def __init__(self, token):
        super().__init__("Syntax error at: " + str(token))

        self.token = token


class InterpreterError(Exception):
    """An error that occurs during execution."""

    pass


class NodeVisitor():
    """A general visitor class for Nodes."""

    def visit_Node(self, node):
        method = f"visit_{type(node).__name__}"
        return getattr(self, method)(node)


class Env(dict):
    """
    A wrapper class that provides a dictionary interface to an environment.
    This is primarily used as the top level scope of an interpreter and is
    also used by function environments for storing bindings.
    """

    def __init__(self, enclosing=None):
        self._enclosing = enclosing  # Reference to parent Environment

    @property
    def enclosing(self):
        return self._enclosing


class Interpreter(NodeVisitor):
    """
    The interpreter class runs code generated by the compiler and returns
    output.
    """

    def __init__(self, node):
        self.node = node

        # Global scope: stores values of identifiers
        self.globals = Env()

        # Local scope: stores values of identifiers defined within functions
        self._locals = {}

        # A list of identifiers that are currently being executed by the
        # interpreter (used for error messages).
        self.identifiers_being_executed = []

    def visit_Node(self, node):  # noqa: N802
        """Execute an expression"""
        return self.visit(node)

    @property
    def locals(self):
        return self._locals

    def execute_function(self, function):
        """Execute a function given its root Node and identifier to be bound."""

        # Add the given identifier to a list of identifiers currently being
        # executed so we know where the error messages will report.
        self.identifiers_being_executed += [function]

        # Create an environment for the new scope and set it as the current
        # environment so that its values take precedence over the global ones.
        env = Env(self.globals)  # pylint: disable=E1102

        try:
            # Assign the given identifier to the newly created environment,
            # setting it as the current environment in preparation for execution.
            self._locals[function] = env

            # Execute the Node associated with that identifier and return its value.
            return self.visit(self.node)
        finally:
            # Remove the identifier being executed from our list of identifiers. This is
            # necessary to prevent us from reporting errors about things like "x not found".
            if function in self._locals:
                del self._locals[function]

            # Set back the global environment for the interpreter.
            self._locals = {}

    def visit_Program(self, node):
        """Execute a program given a list of Nodes"""
        for child in node.children:
            self.visit(child)

    def visit_NumberLiteralNode(self, node):  # noqa: N802
        return node.value

    def visit_InfixExprNode(self, node):  # noqa: N802
        """Execute an operator with two operands."""

        left = self.visit(node.left)
        right = self.visit(node.right)

        if type(node).__name__ == "ProductNode":
            return self._product_operation(node)(left, right)

        elif type(node).__name__ == "SumNode":
            return self._sum_operation(node)(left, right)

        else:  # type(node).__name__ == "CountNode" or "MinNode", etc.
            return self._arithmetic_operation(node)(left, right)

    def visit_ProductNode(self, node):  # noqa: N802
        return reduce(lambda acc, x: acc * x, [self.visit(x) for x in node.children])

    def _product_operation(self, node):
        """Return a product function that matches the given node type."""

        if type(node).__name__ == "ProductNode":
            return self._product_operation

        elif type(node).__name__ == "CountNode":

            def func(left, right):
                return int(right / left) - 1
            return func
        else:
            raise CompilerError(node.left)

    def visit_SumNode(self, node):  # noqa: N802
        return reduce(lambda acc, x: acc + self.visit(x), [self.visit(x) for x in node.children])

    def _sum_operation(self, node):
        """Return a sum function that matches the given node type."""

        if type(node).__name__ == "SumNode":
            return self._product_operation

        elif type(node).__name__ == "CountNode":

            def func(left, right):
                return int(right / left) - 1 + right % left
            return func
        else:
            raise CompilerError(node.left)

    def visit_IdentifierNode(self, node):  # noqa: N802

        if self._locals and node in self._locals:
            return self._locals[node]

        elif self.globals and node in self.globals:
            return self.globals[node]
        else:
            raise InterpreterError(f"Identifier {node} not found")

    def visit_NumberLiteralNode(self, node):  # noqa: N802
        """Return the value of a number literal"""

        return int(node)

    def visit_VariableAssignmentNode(self, node):  # noqa: N802
        """Execute an assignment statement to a variable."""

        # Create a dictionary for each VariableAssigmentNode in this program.
        self._locals[node] = self.visit(node.value)

    def visit_BlockStatementNode(self, node):  # noqa: N802
        """Execute a block of statements"""
        for child in node.children:
            try:
                self.visit(child)

            except InterpreterError as error:

                message = f"Line {error.token.row} - Column {error.token.col}: " \
                          + str(error.message())

                raise InterpreterError(message, node)

        # Return the value of its last child statement or None if there are no children
        return self._locals["<return>"]

    def visit_VariableDeclarationNode(self, node):  # noqa: N802
        """Execute a Variable Declaration"""

        # Declare the variable on the enclosing scope.
        self._enclosing[node] = None

    def visit_WhileLoopNode(self, node):  # noqa: N802
        """Execute a while loop given a condition and body."""
        try:
            while True:
                if self.visit(node) is False:
                    break

        except InterpreterError as error:

            message = f"Line {error.token.row} - Column {error.token.col}: " \
                      + str(error.message())

            raise InterpreterError(message, node)

    def visit_IfStatementNode(self, node):  # noqa: N802
        """Execute a conditional statement given an expression and body."""
        if self.visit(node.condition):
            return self.visit(node.body)

        elif len(node.else_) > 0:

            for child in node.else_:
                try:
                    return self.visit(child)

                except InterpreterError as error:

                    message = f"Line {error.token.row} - Column {error.token.col}: " \
                              + str(error.message())

                    raise InterpreterError(message, node)

    def visit_FunctionDeclarationNode(self, node):  # noqa: N802
        """Execute a function definition."""

        if self.globals[node] is None:
            # Create an environment for the new scope and set it as the current
            # environment so that its values take precedence over the global ones.
            env = Env(self._locals)

            try:
                # Assign the given identifier to the newly created environment, setting it
                # as the current environment in preparation for execution. This is necessary
                # because any function defined inside of a function will have a different
                # Environment than the outer one and must use its own local variable scope
                # before executing the statements within that function definition. Otherwise, the
                # assignment to a global identifier in the outer Environment would override this
                # definition.

                self._locals[node] = env

                for child in node.children:
                    try:
                        self.visit(child)

                    except InterpreterError as error:

                        message = f"Line {error.token.row} - Column {error.token.col}: " \
                                  + str(error.message())

                        raise InterpreterError(message, node)

            finally:
                # Set back the global environment for the interpreter.
                self._locals = {}

    def visit_ReturnStatementNode(self, node):  # noqa: N802
        """Execute a return statement given an expression."""

        try:
            return self.visit(node.value)
        except InterpreterError as error:

            message = f"Line {error.token.row} - Column {error.token.col}: " \
                      + str(error.message())

            raise InterpreterError(message, node)

    def visit_ExpressionStatementNode(self, node):  # noqa: N802
        """Execute a single statement."""
        self.visit(node.value)

        return None


def interpreter():
    """Run the REPL"""

    compiler = Compiler()

    while True:
        try:
            text = input("> ")

            if not text:
                break

            tree, errors = compiler.parse(text)

            if len(errors):
                for error in errors:
                    print(error)

                continue

        except Exception as e:  # pylint: disable=broad-except
            traceback.print_exc()
            continue

        interpreter = Interpreter(tree[0])
        try:
            interpreter.visit(tree[0])
        except InterpreterError as error:

            message = f"Line {error.token.row} - Column {error.token.col}: " \
                      + str(error.message())

            raise InterpreterError(message, node)

        print("=" * 25)


if __name__ == "__main__":
    interpreter()
