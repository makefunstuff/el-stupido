use crate::compose::ValidComposition;
use std::fmt::Write;

// Embed primitive source code at compile time.
// These are real, tested Rust modules — not string templates.
const GRUG_SRC: &str = include_str!("../primitives/src/grug.rs");
const HTTP_SRC: &str = include_str!("../primitives/src/http.rs");
const HTML_SRC: &str = include_str!("../primitives/src/html.rs");

/// What the composition needs — drives which modules to embed.
struct Needs {
    http: bool,
    grug: bool,
    html: bool,
    json: bool,
}

fn analyze(comp: &ValidComposition) -> Needs {
    Needs {
        http: comp.calls.iter().any(|c| c.primitive_id == "http_listen"),
        grug: comp.calls.iter().any(|c| c.primitive_id == "grug_store"),
        html: comp
            .calls
            .iter()
            .any(|c| c.primitive_id == "html_list" || c.primitive_id == "html_form"),
        json: comp.calls.iter().any(|c| c.primitive_id == "json_respond"),
    }
}

/// Emit a self-contained Rust source file from a validated composition.
///
/// The output includes inline modules with the real primitive implementations
/// (embedded via include_str at esc compile time), plus a generated main()
/// that wires them together based on the manifest.
pub fn emit_rust(comp: &ValidComposition) -> String {
    let mut out = String::with_capacity(32768);
    let needs = analyze(comp);

    // File header
    writeln!(out, "// Generated by esc (el-stupido compiler)").unwrap();
    writeln!(
        out,
        "#![allow(dead_code, unused_imports, unused_variables)]"
    )
    .unwrap();
    writeln!(out).unwrap();

    // Embed only the modules this composition uses.
    // The module source is real Rust code from the primitives crate.
    if needs.grug {
        writeln!(out, "mod grug {{\n{}\n}}\n", GRUG_SRC).unwrap();
    }
    if needs.http {
        writeln!(out, "mod http {{\n{}\n}}\n", HTTP_SRC).unwrap();
    }
    if needs.html {
        writeln!(out, "mod html {{\n{}\n}}\n", HTML_SRC).unwrap();
    }

    // Generate main
    if needs.http {
        emit_server_main(&mut out, comp, &needs);
    }
    // TODO: timer_loop / gpio main variants

    out
}

/// Generate main() for an HTTP server composition.
fn emit_server_main(out: &mut String, comp: &ValidComposition, needs: &Needs) {
    // Extract composition parameters
    let port = comp
        .calls
        .iter()
        .find(|c| c.primitive_id == "http_listen")
        .and_then(|c| c.params.get("port"))
        .and_then(|v| v.as_u16())
        .unwrap_or(8080);

    let store_info = comp
        .calls
        .iter()
        .find(|c| c.primitive_id == "grug_store")
        .map(|c| {
            let name = c.params["name"].as_str().unwrap();
            let fields = c.params["fields"].as_str_list().unwrap();
            (name, fields.to_vec(), format!("{name}.grug"))
        });

    let form_fields: Option<Vec<String>> = comp
        .calls
        .iter()
        .find(|c| c.primitive_id == "html_form")
        .and_then(|c| c.params.get("fields"))
        .and_then(|v| v.as_str_list())
        .map(|f| f.to_vec());

    let routes: Vec<_> = comp
        .calls
        .iter()
        .filter(|c| c.primitive_id == "route")
        .collect();

    // Emit main
    writeln!(out, "fn main() {{").unwrap();
    writeln!(out, "    let mut server = http::HttpServer::new({port});").unwrap();

    for route in &routes {
        let method = route.params["method"].as_str().unwrap();
        let path = route.params["path"].as_str().unwrap();
        writeln!(out).unwrap();

        if method == "GET" && !path.contains("delete") && needs.html {
            // HTML list+form page
            if let Some((name, _, ref grug_path)) = store_info {
                writeln!(
                    out,
                    "    server.route(\"{method}\", \"{path}\", |_req, resp| {{"
                )
                .unwrap();
                writeln!(
                    out,
                    "        let store = grug::GrugStore::open(\"{grug_path}\");"
                )
                .unwrap();
                writeln!(
                    out,
                    "        let mut page = html::HtmlPage::new(\"{name}\");"
                )
                .unwrap();
                writeln!(out, "        page.list(&store);").unwrap();
                if let Some(ref fields) = form_fields {
                    let fields_str = fields
                        .iter()
                        .map(|f| format!("\"{f}\""))
                        .collect::<Vec<_>>()
                        .join(", ");
                    writeln!(out, "        page.form(\"{path}\", &[{fields_str}]);").unwrap();
                }
                writeln!(out, "        resp.html(&page.render());").unwrap();
                writeln!(out, "    }});").unwrap();
            }
        } else if method == "GET" && !path.contains("delete") && needs.json {
            // JSON API response
            if let Some((_, _, ref grug_path)) = store_info {
                writeln!(
                    out,
                    "    server.route(\"{method}\", \"{path}\", |_req, resp| {{"
                )
                .unwrap();
                writeln!(
                    out,
                    "        let store = grug::GrugStore::open(\"{grug_path}\");"
                )
                .unwrap();
                writeln!(out, "        resp.json(&store.to_json());").unwrap();
                writeln!(out, "    }});").unwrap();
            }
        } else if method == "POST" {
            // Create from form body
            if let Some((_, ref fields, ref grug_path)) = store_info {
                let fields_str = fields
                    .iter()
                    .map(|f| format!("\"{f}\""))
                    .collect::<Vec<_>>()
                    .join(", ");
                writeln!(
                    out,
                    "    server.route(\"{method}\", \"{path}\", |req, resp| {{"
                )
                .unwrap();
                writeln!(
                    out,
                    "        let mut store = grug::GrugStore::open(\"{grug_path}\");"
                )
                .unwrap();
                writeln!(
                    out,
                    "        store.create_from_form(req.body(), &[{fields_str}]);"
                )
                .unwrap();
                writeln!(out, "        resp.redirect(\"/\");").unwrap();
                writeln!(out, "    }});").unwrap();
            }
        } else if path.contains("delete") {
            // Delete by query param
            if let Some((_, _, ref grug_path)) = store_info {
                writeln!(
                    out,
                    "    server.route(\"{method}\", \"{path}\", |req, resp| {{"
                )
                .unwrap();
                writeln!(
                    out,
                    "        let mut store = grug::GrugStore::open(\"{grug_path}\");"
                )
                .unwrap();
                writeln!(out, "        if let Some(id) = req.query_param(\"id\") {{").unwrap();
                writeln!(out, "            store.delete(&id);").unwrap();
                writeln!(out, "        }}").unwrap();
                writeln!(out, "        resp.redirect(\"/\");").unwrap();
                writeln!(out, "    }});").unwrap();
            }
        }
    }

    writeln!(out).unwrap();
    writeln!(out, "    server.run();").unwrap();
    writeln!(out, "}}").unwrap();
}
