use crate::compose::ValidComposition;
use std::collections::HashMap;
use std::fmt::Write;

fn rust_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

fn f64_literal(n: f64) -> String {
    let mut s = n.to_string();
    if !s.contains('.') && !s.contains('e') && !s.contains('E') {
        s.push_str(".0");
    }
    s
}

fn bind_var(
    node: &crate::compose::ValidNode,
    bind_name: &str,
    vars: &HashMap<String, String>,
) -> String {
    let target = node.bind.get(bind_name).unwrap();
    vars.get(target).unwrap().clone()
}

/// Emit a self-contained Rust source file from a validated composition graph.
pub fn emit_rust(comp: &ValidComposition) -> String {
    let mut out = String::with_capacity(32768);

    writeln!(out, "// Generated by esc (el-stupido compiler)").unwrap();
    writeln!(out, "// app: {}", rust_string(&comp.app)).unwrap();
    if comp.capabilities.is_empty() {
        writeln!(out, "// capabilities: []").unwrap();
    } else {
        writeln!(out, "// capabilities: [{}]", comp.capabilities.join(", ")).unwrap();
    }
    writeln!(
        out,
        "#![allow(dead_code, unused_imports, unused_variables)]"
    )
    .unwrap();
    writeln!(out).unwrap();

    writeln!(out, "fn main() {{").unwrap();

    let mut vars: HashMap<String, String> = HashMap::new();

    for (idx, node) in comp.nodes.iter().enumerate() {
        let var = format!("v{idx}");
        writeln!(
            out,
            "    // node {} ({})",
            rust_string(&node.id),
            node.primitive_id
        )
        .unwrap();

        match node.primitive_id.as_str() {
            "const_num" => {
                let value = node.params["value"].as_f64().unwrap();
                writeln!(out, "    let {var}: f64 = {};", f64_literal(value)).unwrap();
            }
            "const_str" => {
                let value = node.params["value"].as_str().unwrap();
                writeln!(
                    out,
                    "    let {var}: String = \"{}\".to_string();",
                    rust_string(value)
                )
                .unwrap();
            }
            "add" => {
                let lhs = bind_var(node, "lhs", &vars);
                let rhs = bind_var(node, "rhs", &vars);
                writeln!(out, "    let {var}: f64 = {lhs} + {rhs};").unwrap();
            }
            "sub" => {
                let lhs = bind_var(node, "lhs", &vars);
                let rhs = bind_var(node, "rhs", &vars);
                writeln!(out, "    let {var}: f64 = {lhs} - {rhs};").unwrap();
            }
            "mul" => {
                let lhs = bind_var(node, "lhs", &vars);
                let rhs = bind_var(node, "rhs", &vars);
                writeln!(out, "    let {var}: f64 = {lhs} * {rhs};").unwrap();
            }
            "div" => {
                let lhs = bind_var(node, "lhs", &vars);
                let rhs = bind_var(node, "rhs", &vars);
                writeln!(out, "    let {var}: f64 = {lhs} / {rhs};").unwrap();
            }
            "gt" => {
                let lhs = bind_var(node, "lhs", &vars);
                let rhs = bind_var(node, "rhs", &vars);
                writeln!(out, "    let {var}: bool = {lhs} > {rhs};").unwrap();
            }
            "eq_num" => {
                let lhs = bind_var(node, "lhs", &vars);
                let rhs = bind_var(node, "rhs", &vars);
                writeln!(out, "    let {var}: bool = {lhs} == {rhs};").unwrap();
            }
            "and_bool" => {
                let lhs = bind_var(node, "lhs", &vars);
                let rhs = bind_var(node, "rhs", &vars);
                writeln!(out, "    let {var}: bool = {lhs} && {rhs};").unwrap();
            }
            "or_bool" => {
                let lhs = bind_var(node, "lhs", &vars);
                let rhs = bind_var(node, "rhs", &vars);
                writeln!(out, "    let {var}: bool = {lhs} || {rhs};").unwrap();
            }
            "not_bool" => {
                let value = bind_var(node, "value", &vars);
                writeln!(out, "    let {var}: bool = !{value};").unwrap();
            }
            "select_num" => {
                let cond = bind_var(node, "cond", &vars);
                let then_v = bind_var(node, "then", &vars);
                let else_v = bind_var(node, "else", &vars);
                writeln!(
                    out,
                    "    let {var}: f64 = if {cond} {{ {then_v} }} else {{ {else_v} }};"
                )
                .unwrap();
            }
            "select_str" => {
                let cond = bind_var(node, "cond", &vars);
                let then_v = bind_var(node, "then", &vars);
                let else_v = bind_var(node, "else", &vars);
                writeln!(
                    out,
                    "    let {var}: String = if {cond} {{ {then_v}.clone() }} else {{ {else_v}.clone() }};"
                )
                .unwrap();
            }
            "to_string" => {
                let value = bind_var(node, "value", &vars);
                writeln!(out, "    let {var}: String = format!(\"{{}}\", {value});").unwrap();
            }
            "concat" => {
                let left = bind_var(node, "left", &vars);
                let right = bind_var(node, "right", &vars);
                writeln!(
                    out,
                    "    let {var}: String = format!(\"{{}}{{}}\", {left}, {right});"
                )
                .unwrap();
            }
            "len_str" => {
                let text = bind_var(node, "text", &vars);
                writeln!(out, "    let {var}: f64 = {text}.chars().count() as f64;").unwrap();
            }
            "repeat_str" => {
                let text = bind_var(node, "text", &vars);
                let times = bind_var(node, "times", &vars);
                writeln!(out, "    let {var}: String = {{").unwrap();
                writeln!(
                    out,
                    "        let count = if {times}.is_finite() && {times} > 0.0 {{ {times}.floor() as usize }} else {{ 0 }};"
                )
                .unwrap();
                writeln!(out, "        let count = count.min(10_000);").unwrap();
                writeln!(out, "        {text}.repeat(count)").unwrap();
                writeln!(out, "    }};").unwrap();
            }
            "cwd" => {
                writeln!(out, "    let {var}: String = std::env::current_dir().map(|p| p.to_string_lossy().into_owned()).unwrap_or_else(|_| \".\".to_string());").unwrap();
            }
            "path_join" => {
                let left = bind_var(node, "left", &vars);
                let right = bind_var(node, "right", &vars);
                writeln!(out, "    let {var}: String = {{").unwrap();
                writeln!(
                    out,
                    "        let mut p = std::path::PathBuf::from(&{left});"
                )
                .unwrap();
                writeln!(out, "        p.push(&{right});").unwrap();
                writeln!(out, "        p.to_string_lossy().into_owned()").unwrap();
                writeln!(out, "    }};").unwrap();
            }
            "read_stdin" => {
                let prompt = node
                    .params
                    .get("prompt")
                    .and_then(|v| v.as_str())
                    .unwrap_or("");
                writeln!(out, "    let {var}: String = {{").unwrap();
                writeln!(out, "        use std::io::Write as _;").unwrap();
                writeln!(out, "        let mut line = String::new();").unwrap();
                writeln!(out, "        print!(\"{}\");", rust_string(prompt)).unwrap();
                writeln!(out, "        let _ = std::io::stdout().flush();").unwrap();
                writeln!(
                    out,
                    "        std::io::stdin().read_line(&mut line).expect(\"stdin read failed\");"
                )
                .unwrap();
                writeln!(
                    out,
                    "        line.trim_end_matches(&['\\r', '\\n'][..]).to_string()"
                )
                .unwrap();
                writeln!(out, "    }};").unwrap();
            }
            "parse_num" => {
                let text = bind_var(node, "text", &vars);
                writeln!(
                    out,
                    "    let {var}: f64 = {text}.trim().parse::<f64>().unwrap_or(0.0);"
                )
                .unwrap();
            }
            "read_file" => {
                let path = node.params["path"].as_str().unwrap();
                writeln!(
                    out,
                    "    let {var}: String = std::fs::read_to_string(\"{}\").unwrap_or_default();",
                    rust_string(path)
                )
                .unwrap();
            }
            "read_file_dyn" => {
                let path = bind_var(node, "path", &vars);
                writeln!(
                    out,
                    "    let {var}: String = std::fs::read_to_string(&{path}).unwrap_or_default();"
                )
                .unwrap();
            }
            "write_file" => {
                let path = node.params["path"].as_str().unwrap();
                let content = bind_var(node, "content", &vars);
                writeln!(out, "    let {var}: () = {{").unwrap();
                writeln!(
                    out,
                    "        let _ = std::fs::write(\"{}\", {content});",
                    rust_string(path)
                )
                .unwrap();
                writeln!(out, "    }};").unwrap();
            }
            "write_file_dyn" => {
                let path = bind_var(node, "path", &vars);
                let content = bind_var(node, "content", &vars);
                writeln!(out, "    let {var}: () = {{").unwrap();
                writeln!(out, "        let _ = std::fs::write(&{path}, &{content});").unwrap();
                writeln!(out, "    }};").unwrap();
            }
            "print_num" => {
                let value = bind_var(node, "value", &vars);
                writeln!(
                    out,
                    "    let {var}: () = {{ println!(\"{{}}\", {value}); }};"
                )
                .unwrap();
            }
            "print_str" => {
                let value = bind_var(node, "value", &vars);
                writeln!(
                    out,
                    "    let {var}: () = {{ println!(\"{{}}\", {value}); }};"
                )
                .unwrap();
            }
            other => {
                writeln!(
                    out,
                    "    compile_error!(\"unsupported primitive in emitter: {}\");",
                    rust_string(other)
                )
                .unwrap();
            }
        }

        vars.insert(node.id.clone(), var);
        writeln!(out).unwrap();
    }

    writeln!(out, "}}").unwrap();

    out
}
