use crate::compose::ValidComposition;
use std::fmt::Write;

/// Emit a complete, self-contained C source file from a validated composition.
pub fn emit_c(comp: &ValidComposition) -> String {
    let mut c = String::with_capacity(8192);

    // Analyze what the composition needs.
    let has_server = comp.calls.iter().any(|c| c.primitive_id == "http_listen");
    let has_grug = comp.calls.iter().any(|c| c.primitive_id == "grug_store");
    let has_timer = comp.calls.iter().any(|c| c.primitive_id == "timer_loop");
    let has_gpio = comp
        .calls
        .iter()
        .any(|c| c.primitive_id == "gpio_read" || c.primitive_id == "gpio_write");

    // --- Headers ---
    writeln!(c, "/* Generated by esc (el-stupido compiler) */").unwrap();
    writeln!(c, "#include <stdio.h>").unwrap();
    writeln!(c, "#include <stdlib.h>").unwrap();
    writeln!(c, "#include <string.h>").unwrap();

    if has_server {
        writeln!(c, "#include <unistd.h>").unwrap();
        writeln!(c, "#include <sys/socket.h>").unwrap();
        writeln!(c, "#include <netinet/in.h>").unwrap();
        writeln!(c, "#include <signal.h>").unwrap();
    }
    if has_timer {
        writeln!(c, "#include <unistd.h>").unwrap();
        writeln!(c, "#include <time.h>").unwrap();
    }
    if has_gpio {
        writeln!(c, "#include <fcntl.h>").unwrap();
        writeln!(c, "#include <unistd.h>").unwrap();
    }
    writeln!(c).unwrap();

    // --- Grug inline implementation ---
    if has_grug {
        emit_grug_impl(&mut c);
    }

    // --- GPIO helpers ---
    if has_gpio {
        emit_gpio_impl(&mut c);
    }

    // --- HTTP helpers ---
    if has_server {
        emit_http_impl(&mut c);
    }

    // --- Model-specific handlers ---
    let stores: Vec<_> = comp
        .calls
        .iter()
        .filter(|c| c.primitive_id == "grug_store")
        .collect();

    for store in &stores {
        let name = store.params["name"].as_str().unwrap();
        let fields = store.params["fields"].as_str_list().unwrap();
        emit_store_handlers(&mut c, name, fields);
    }

    // --- HTML handlers ---
    // If we have both html_list and html_form, merge them into one handler.
    let form_fields: Option<Vec<String>> = comp
        .calls
        .iter()
        .find(|c| c.primitive_id == "html_form")
        .and_then(|c| c.params["fields"].as_str_list().map(|f| f.to_vec()));

    for call in &comp.calls {
        match call.primitive_id.as_str() {
            "html_list" => {
                let model = call.params["model"].as_str().unwrap();
                emit_html_list_page(&mut c, model, form_fields.as_deref());
            }
            "json_respond" => {
                let model = call.params["model"].as_str().unwrap();
                emit_json_respond(&mut c, model);
            }
            _ => {}
        }
    }

    // --- Route dispatch ---
    if has_server {
        let routes: Vec<_> = comp
            .calls
            .iter()
            .filter(|c| c.primitive_id == "route")
            .collect();
        emit_route_dispatch(&mut c, &routes);
    }

    // --- Threshold logic ---
    let thresholds: Vec<_> = comp
        .calls
        .iter()
        .filter(|c| c.primitive_id == "threshold")
        .collect();
    if !thresholds.is_empty() {
        emit_threshold_check(&mut c, &thresholds);
    }

    // --- Main ---
    emit_main(&mut c, comp, has_server, has_timer);

    c
}

fn emit_grug_impl(c: &mut String) {
    writeln!(c, "/* --- grug: line-based key-value persistence --- */").unwrap();
    writeln!(
        c,
        r#"
#define GRUG_MAX_LINE 4096
#define GRUG_MAX_ENTRIES 1024

typedef struct {{
    char key[256];
    char val[1024];
}} GrugKV;

typedef struct {{
    char id[64];
    GrugKV kvs[32];
    int nkv;
}} GrugEntry;

typedef struct {{
    GrugEntry entries[GRUG_MAX_ENTRIES];
    int n;
    char path[256];
}} GrugFile;

static void grug_init(GrugFile *g, const char *path) {{
    memset(g, 0, sizeof(*g));
    snprintf(g->path, sizeof(g->path), "%s", path);
    FILE *f = fopen(path, "r");
    if (!f) return;
    char line[GRUG_MAX_LINE];
    GrugEntry *cur = NULL;
    while (fgets(line, sizeof(line), f)) {{
        line[strcspn(line, "\n")] = 0;
        if (line[0] == '[') {{
            if (g->n >= GRUG_MAX_ENTRIES) break;
            cur = &g->entries[g->n++];
            char *end = strchr(line, ']');
            if (end) {{ *end = 0; snprintf(cur->id, sizeof(cur->id), "%s", line + 1); }}
        }} else if (cur && strchr(line, '=')) {{
            char *eq = strchr(line, '=');
            *eq = 0;
            char *k = line; while (*k == ' ') k++;
            char *ke = eq - 1; while (ke > k && *ke == ' ') *ke-- = 0;
            char *v = eq + 1; while (*v == ' ') v++;
            if (cur->nkv < 32) {{
                snprintf(cur->kvs[cur->nkv].key, 256, "%s", k);
                snprintf(cur->kvs[cur->nkv].val, 1024, "%s", v);
                cur->nkv++;
            }}
        }}
    }}
    fclose(f);
}}

static void grug_save(GrugFile *g) {{
    FILE *f = fopen(g->path, "w");
    if (!f) return;
    for (int i = 0; i < g->n; i++) {{
        fprintf(f, "[%s]\n", g->entries[i].id);
        for (int j = 0; j < g->entries[i].nkv; j++)
            fprintf(f, "%s = %s\n", g->entries[i].kvs[j].key, g->entries[i].kvs[j].val);
        fprintf(f, "\n");
    }}
    fclose(f);
}}

static void grug_add(GrugFile *g, const char *id) {{
    if (g->n >= GRUG_MAX_ENTRIES) return;
    GrugEntry *e = &g->entries[g->n++];
    memset(e, 0, sizeof(*e));
    snprintf(e->id, sizeof(e->id), "%s", id);
}}

static void grug_set(GrugFile *g, const char *id, const char *key, const char *val) {{
    for (int i = 0; i < g->n; i++) {{
        if (strcmp(g->entries[i].id, id) == 0) {{
            for (int j = 0; j < g->entries[i].nkv; j++) {{
                if (strcmp(g->entries[i].kvs[j].key, key) == 0) {{
                    snprintf(g->entries[i].kvs[j].val, 1024, "%s", val);
                    return;
                }}
            }}
            if (g->entries[i].nkv < 32) {{
                snprintf(g->entries[i].kvs[g->entries[i].nkv].key, 256, "%s", key);
                snprintf(g->entries[i].kvs[g->entries[i].nkv].val, 1024, "%s", val);
                g->entries[i].nkv++;
            }}
            return;
        }}
    }}
}}

static const char *grug_get(GrugFile *g, const char *id, const char *key) {{
    for (int i = 0; i < g->n; i++) {{
        if (strcmp(g->entries[i].id, id) == 0) {{
            for (int j = 0; j < g->entries[i].nkv; j++)
                if (strcmp(g->entries[i].kvs[j].key, key) == 0)
                    return g->entries[i].kvs[j].val;
        }}
    }}
    return "";
}}

static void grug_del(GrugFile *g, const char *id) {{
    for (int i = 0; i < g->n; i++) {{
        if (strcmp(g->entries[i].id, id) == 0) {{
            memmove(&g->entries[i], &g->entries[i+1], (g->n - i - 1) * sizeof(GrugEntry));
            g->n--;
            return;
        }}
    }}
}}

static int grug_next_id(GrugFile *g) {{
    int max = 0;
    for (int i = 0; i < g->n; i++) {{
        int v = atoi(g->entries[i].id);
        if (v > max) max = v;
    }}
    return max + 1;
}}
"#
    )
    .unwrap();
}

fn emit_gpio_impl(c: &mut String) {
    writeln!(c, "/* --- GPIO via sysfs --- */").unwrap();
    writeln!(
        c,
        r#"
static void gpio_export(int pin) {{
    char buf[64];
    snprintf(buf, sizeof(buf), "/sys/class/gpio/export");
    FILE *f = fopen(buf, "w");
    if (f) {{ fprintf(f, "%d", pin); fclose(f); }}
    usleep(100000);
}}

static void gpio_direction(int pin, const char *dir) {{
    char buf[64];
    snprintf(buf, sizeof(buf), "/sys/class/gpio/gpio%d/direction", pin);
    FILE *f = fopen(buf, "w");
    if (f) {{ fprintf(f, "%s", dir); fclose(f); }}
}}

static int gpio_read_value(int pin) {{
    char buf[64], val[8];
    snprintf(buf, sizeof(buf), "/sys/class/gpio/gpio%d/value", pin);
    FILE *f = fopen(buf, "r");
    if (!f) return -1;
    if (fgets(val, sizeof(val), f)) {{ fclose(f); return atoi(val); }}
    fclose(f);
    return -1;
}}

static void gpio_write_value(int pin, int val) {{
    char buf[64];
    snprintf(buf, sizeof(buf), "/sys/class/gpio/gpio%d/value", pin);
    FILE *f = fopen(buf, "w");
    if (f) {{ fprintf(f, "%d", val); fclose(f); }}
}}
"#
    )
    .unwrap();
}

fn emit_http_impl(c: &mut String) {
    writeln!(c, "/* --- Minimal HTTP server --- */").unwrap();
    writeln!(c, r#"
static char req_buf[8192];
static char req_method[16];
static char req_path[1024];
static char req_body[4096];

static int http_listen(int port) {{
    signal(SIGCHLD, SIG_IGN);
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd < 0) {{ perror("socket"); exit(1); }}
    int opt = 1;
    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    struct sockaddr_in addr = {{
        .sin_family = AF_INET,
        .sin_port = htons(port),
        .sin_addr.s_addr = INADDR_ANY
    }};
    if (bind(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {{ perror("bind"); exit(1); }}
    if (listen(fd, 64) < 0) {{ perror("listen"); exit(1); }}
    printf("listening on :%d\n", port);
    return fd;
}}

static void http_parse_request(int client) {{
    memset(req_buf, 0, sizeof(req_buf));
    memset(req_method, 0, sizeof(req_method));
    memset(req_path, 0, sizeof(req_path));
    memset(req_body, 0, sizeof(req_body));
    int n = read(client, req_buf, sizeof(req_buf) - 1);
    if (n <= 0) return;
    sscanf(req_buf, "%15s %1023s", req_method, req_path);
    char *body = strstr(req_buf, "\r\n\r\n");
    if (body) {{
        body += 4;
        snprintf(req_body, sizeof(req_body), "%s", body);
    }}
}}

static void http_respond(int client, int status, const char *ctype, const char *body) {{
    char hdr[512];
    int blen = (int)strlen(body);
    int hlen = snprintf(hdr, sizeof(hdr),
        "HTTP/1.1 %d OK\r\nContent-Type: %s\r\nContent-Length: %d\r\nConnection: close\r\n\r\n",
        status, ctype, blen);
    write(client, hdr, hlen);
    write(client, body, blen);
}}

static void http_redirect(int client, const char *loc) {{
    char hdr[512];
    int hlen = snprintf(hdr, sizeof(hdr),
        "HTTP/1.1 302 Found\r\nLocation: %s\r\nContent-Length: 0\r\nConnection: close\r\n\r\n", loc);
    write(client, hdr, hlen);
}}

static char *url_decode(const char *src, char *dst, int max) {{
    char *d = dst;
    char *end = dst + max - 1;
    while (*src && d < end) {{
        if (*src == '%' && src[1] && src[2]) {{
            char hex[3] = {{ src[1], src[2], 0 }};
            *d++ = (char)strtol(hex, NULL, 16);
            src += 3;
        }} else if (*src == '+') {{
            *d++ = ' '; src++;
        }} else {{
            *d++ = *src++;
        }}
    }}
    *d = 0;
    return dst;
}}

static const char *form_value(const char *body, const char *key, char *out, int max) {{
    char search[256];
    snprintf(search, sizeof(search), "%s=", key);
    const char *p = strstr(body, search);
    if (!p) {{ out[0] = 0; return out; }}
    p += strlen(search);
    const char *end = strchr(p, '&');
    int len = end ? (int)(end - p) : (int)strlen(p);
    if (len >= max) len = max - 1;
    char encoded[1024];
    memcpy(encoded, p, len);
    encoded[len] = 0;
    url_decode(encoded, out, max);
    return out;
}}
"#).unwrap();
}

fn emit_store_handlers(c: &mut String, name: &str, fields: &[String]) {
    let grug_path = format!("{}.grug", name);

    writeln!(c, "static GrugFile {name}_db;").unwrap();
    writeln!(c).unwrap();

    // create handler
    writeln!(c, "static void {name}_create(void) {{").unwrap();
    writeln!(c, "    char id_str[32];").unwrap();
    writeln!(
        c,
        "    snprintf(id_str, sizeof(id_str), \"%d\", grug_next_id(&{name}_db));"
    )
    .unwrap();
    writeln!(c, "    grug_add(&{name}_db, id_str);").unwrap();
    for f in fields {
        writeln!(
            c,
            "    {{ char val[1024]; form_value(req_body, \"{f}\", val, sizeof(val));"
        )
        .unwrap();
        writeln!(c, "      grug_set(&{name}_db, id_str, \"{f}\", val); }}").unwrap();
    }
    writeln!(c, "    grug_save(&{name}_db);").unwrap();
    writeln!(c, "}}").unwrap();
    writeln!(c).unwrap();

    // delete handler
    writeln!(c, "static void {name}_delete(const char *id) {{").unwrap();
    writeln!(c, "    grug_del(&{name}_db, id);").unwrap();
    writeln!(c, "    grug_save(&{name}_db);").unwrap();
    writeln!(c, "}}").unwrap();
    writeln!(c).unwrap();

    // init
    writeln!(c, "static void {name}_init(void) {{").unwrap();
    writeln!(c, "    grug_init(&{name}_db, \"{grug_path}\");").unwrap();
    writeln!(c, "}}").unwrap();
    writeln!(c).unwrap();
}

/// Emit a combined list+form handler. If `form_fields` is Some, the form is appended below the table.
fn emit_html_list_page(c: &mut String, model: &str, form_fields: Option<&[String]>) {
    writeln!(c, "static void handle_list_{model}(int client) {{").unwrap();
    writeln!(c, "    char buf[65536];").unwrap();
    writeln!(c, "    int off = 0;").unwrap();
    // HTML header — each snprintf on a single line (C forbids newlines in string literals)
    writeln!(c, r#"    off += snprintf(buf + off, sizeof(buf) - off, "<!DOCTYPE html><html><head><meta charset='utf-8'>");"#).unwrap();
    writeln!(c, r#"    off += snprintf(buf + off, sizeof(buf) - off, "<style>body{{font-family:sans-serif;max-width:800px;margin:40px auto;padding:0 20px}}");"#).unwrap();
    writeln!(c, r#"    off += snprintf(buf + off, sizeof(buf) - off, "table{{width:100%%;border-collapse:collapse}}th,td{{padding:8px;border:1px solid #ddd;text-align:left}}");"#).unwrap();
    writeln!(c, r#"    off += snprintf(buf + off, sizeof(buf) - off, "th{{background:#333;color:#fff}}a{{color:#c33}}</style>");"#).unwrap();
    writeln!(c, r#"    off += snprintf(buf + off, sizeof(buf) - off, "<title>{model}</title></head><body><h1>{model}</h1><table><tr>");"#).unwrap();

    // Discover fields from the first entry dynamically
    writeln!(c, "    if ({model}_db.n > 0) {{").unwrap();
    writeln!(
        c,
        "        for (int j = 0; j < {model}_db.entries[0].nkv; j++)"
    )
    .unwrap();
    writeln!(c, "            off += snprintf(buf + off, sizeof(buf) - off, \"<th>%s</th>\", {model}_db.entries[0].kvs[j].key);").unwrap();
    writeln!(
        c,
        "        off += snprintf(buf + off, sizeof(buf) - off, \"<th></th></tr>\");"
    )
    .unwrap();
    writeln!(c, "        for (int i = 0; i < {model}_db.n; i++) {{").unwrap();
    writeln!(
        c,
        "            off += snprintf(buf + off, sizeof(buf) - off, \"<tr>\");"
    )
    .unwrap();
    writeln!(
        c,
        "            for (int j = 0; j < {model}_db.entries[i].nkv; j++)"
    )
    .unwrap();
    writeln!(c, "                off += snprintf(buf + off, sizeof(buf) - off, \"<td>%s</td>\", {model}_db.entries[i].kvs[j].val);").unwrap();
    writeln!(c, r#"            off += snprintf(buf + off, sizeof(buf) - off, "<td><a href='/delete?id=%s'>delete</a></td></tr>", {model}_db.entries[i].id);"#).unwrap();
    writeln!(c, "        }}").unwrap();
    writeln!(c, "    }} else {{").unwrap();
    writeln!(c, "        off += snprintf(buf + off, sizeof(buf) - off, \"</tr><tr><td>No entries yet</td></tr>\");").unwrap();
    writeln!(c, "    }}").unwrap();
    writeln!(
        c,
        "    off += snprintf(buf + off, sizeof(buf) - off, \"</table>\");"
    )
    .unwrap();

    // Inline the form below the table if fields are provided
    if let Some(fields) = form_fields {
        writeln!(c, r#"    off += snprintf(buf + off, sizeof(buf) - off, "<hr><h2>Add new</h2><form method='POST' action='/'>");"#).unwrap();
        for f in fields {
            writeln!(c, r#"    off += snprintf(buf + off, sizeof(buf) - off, "<label>{f}: <input name='{f}' required></label><br><br>");"#).unwrap();
        }
        writeln!(c, r#"    off += snprintf(buf + off, sizeof(buf) - off, "<button type='submit'>Create</button></form>");"#).unwrap();
    }

    writeln!(
        c,
        r#"    off += snprintf(buf + off, sizeof(buf) - off, "</body></html>");"#
    )
    .unwrap();
    writeln!(c, "    http_respond(client, 200, \"text/html\", buf);").unwrap();
    writeln!(c, "}}").unwrap();
    writeln!(c).unwrap();
}

fn emit_json_respond(c: &mut String, model: &str) {
    writeln!(c, "static void handle_json_{model}(int client) {{").unwrap();
    writeln!(c, "    char buf[65536];").unwrap();
    writeln!(c, "    int off = 0;").unwrap();
    writeln!(
        c,
        "    off += snprintf(buf + off, sizeof(buf) - off, \"[\\n\");"
    )
    .unwrap();
    writeln!(c, "    for (int i = 0; i < {model}_db.n; i++) {{").unwrap();
    writeln!(
        c,
        "        off += snprintf(buf + off, sizeof(buf) - off, \"  {{\\n\");"
    )
    .unwrap();
    writeln!(c, "        off += snprintf(buf + off, sizeof(buf) - off, \"    \\\"id\\\": \\\"%s\\\"\", {model}_db.entries[i].id);").unwrap();
    writeln!(
        c,
        "        for (int j = 0; j < {model}_db.entries[i].nkv; j++)"
    )
    .unwrap();
    writeln!(c, "            off += snprintf(buf + off, sizeof(buf) - off, \",\\n    \\\"%s\\\": \\\"%s\\\"\", {model}_db.entries[i].kvs[j].key, {model}_db.entries[i].kvs[j].val);").unwrap();
    writeln!(c, "        off += snprintf(buf + off, sizeof(buf) - off, \"\\n  }}%s\\n\", i < {model}_db.n - 1 ? \",\" : \"\");").unwrap();
    writeln!(c, "    }}").unwrap();
    writeln!(
        c,
        "    off += snprintf(buf + off, sizeof(buf) - off, \"]\");"
    )
    .unwrap();
    writeln!(
        c,
        "    http_respond(client, 200, \"application/json\", buf);"
    )
    .unwrap();
    writeln!(c, "}}").unwrap();
    writeln!(c).unwrap();
}

fn emit_route_dispatch(c: &mut String, routes: &[&crate::compose::ValidCall]) {
    writeln!(c, "static void dispatch(int client) {{").unwrap();
    for route in routes {
        let method = route.params["method"].as_str().unwrap();
        let path = route.params["path"].as_str().unwrap();
        let handler = route.params["handler"].as_str().unwrap();

        // POST routes are handled in the main loop before dispatch is called — skip them.
        if method == "POST" {
            continue;
        }

        if path.contains("delete") {
            // GET /delete?id=X — handler takes (const char *id), not (int client)
            writeln!(c, "    if (strcmp(req_method, \"{method}\") == 0 && strncmp(req_path, \"{path}\", {plen}) == 0) {{",
                plen = path.len()).unwrap();
            writeln!(c, "        char *qid = strstr(req_path, \"id=\");").unwrap();
            writeln!(c, "        if (qid) {{ qid += 3; {handler}(qid); }}").unwrap();
            writeln!(c, "        http_redirect(client, \"/\");").unwrap();
            writeln!(c, "        return;").unwrap();
            writeln!(c, "    }}").unwrap();
        } else {
            // Normal GET handler takes (int client)
            writeln!(c, "    if (strcmp(req_method, \"{method}\") == 0 && strcmp(req_path, \"{path}\") == 0) {{").unwrap();
            writeln!(c, "        {handler}(client);").unwrap();
            writeln!(c, "        return;").unwrap();
            writeln!(c, "    }}").unwrap();
        }
    }
    writeln!(
        c,
        "    http_respond(client, 404, \"text/plain\", \"404 Not Found\\n\");"
    )
    .unwrap();
    writeln!(c, "}}").unwrap();
    writeln!(c).unwrap();
}

fn emit_threshold_check(c: &mut String, thresholds: &[&crate::compose::ValidCall]) {
    writeln!(c, "static void check_thresholds(void) {{").unwrap();
    for t in thresholds {
        let source = t.params["source"].as_str().unwrap();
        let above = t.params["above"].as_f64().unwrap();
        let action = t.params["action"].as_str().unwrap();
        // source is expected to be a function name like "read_sensor_4"
        writeln!(c, "    if ({source}() > {above:.1}) {action}();").unwrap();
    }
    writeln!(c, "}}").unwrap();
    writeln!(c).unwrap();
}

fn emit_main(c: &mut String, comp: &ValidComposition, has_server: bool, has_timer: bool) {
    writeln!(c, "int main(void) {{").unwrap();

    // Init grug stores
    for call in &comp.calls {
        if call.primitive_id == "grug_store" {
            let name = call.params["name"].as_str().unwrap();
            writeln!(c, "    {name}_init();").unwrap();
        }
    }

    // Init GPIO pins
    for call in &comp.calls {
        match call.primitive_id.as_str() {
            "gpio_read" => {
                let pin = call.params["pin"].as_u16().unwrap();
                writeln!(c, "    gpio_export({pin});").unwrap();
                writeln!(c, "    gpio_direction({pin}, \"in\");").unwrap();
            }
            "gpio_write" => {
                let pin = call.params["pin"].as_u16().unwrap();
                writeln!(c, "    gpio_export({pin});").unwrap();
                writeln!(c, "    gpio_direction({pin}, \"out\");").unwrap();
            }
            _ => {}
        }
    }

    if has_server {
        let port = comp
            .calls
            .iter()
            .find(|c| c.primitive_id == "http_listen")
            .and_then(|c| c.params.get("port"))
            .and_then(|v| v.as_u16())
            .unwrap_or(8080);

        writeln!(c, "    int server_fd = http_listen({port});").unwrap();
        writeln!(c, "    while (1) {{").unwrap();
        writeln!(c, "        struct sockaddr_in ca;").unwrap();
        writeln!(c, "        socklen_t cl = sizeof(ca);").unwrap();
        writeln!(
            c,
            "        int client = accept(server_fd, (struct sockaddr *)&ca, &cl);"
        )
        .unwrap();
        writeln!(c, "        if (client < 0) continue;").unwrap();
        writeln!(c, "        if (fork() == 0) {{").unwrap();
        writeln!(c, "            close(server_fd);").unwrap();

        // Re-init grug stores so each child reads latest state from disk
        for call in &comp.calls {
            if call.primitive_id == "grug_store" {
                let name = call.params["name"].as_str().unwrap();
                writeln!(c, "            {name}_init();").unwrap();
            }
        }

        writeln!(c, "            http_parse_request(client);").unwrap();

        // For POST that creates, call create then redirect
        let has_create = comp.calls.iter().any(|call| {
            call.primitive_id == "route"
                && call.params.get("method").and_then(|v| v.as_str()) == Some("POST")
        });
        if has_create {
            let store_name = comp
                .calls
                .iter()
                .find(|c| c.primitive_id == "grug_store")
                .and_then(|c| c.params.get("name"))
                .and_then(|v| v.as_str())
                .unwrap_or("data");
            writeln!(c, "            if (strcmp(req_method, \"POST\") == 0) {{").unwrap();
            writeln!(c, "                {store_name}_create();").unwrap();
            writeln!(c, "                http_redirect(client, \"/\");").unwrap();
            writeln!(c, "            }} else {{").unwrap();
            writeln!(c, "                dispatch(client);").unwrap();
            writeln!(c, "            }}").unwrap();
        } else {
            writeln!(c, "            dispatch(client);").unwrap();
        }

        writeln!(c, "            close(client);").unwrap();
        writeln!(c, "            exit(0);").unwrap();
        writeln!(c, "        }}").unwrap();
        writeln!(c, "        close(client);").unwrap();
        writeln!(c, "    }}").unwrap();
    } else if has_timer {
        let interval = comp
            .calls
            .iter()
            .find(|c| c.primitive_id == "timer_loop")
            .and_then(|c| c.params.get("interval_ms"))
            .and_then(|v| v.as_u64())
            .unwrap_or(1000);

        writeln!(c, "    while (1) {{").unwrap();
        let has_thresholds = comp.calls.iter().any(|c| c.primitive_id == "threshold");
        if has_thresholds {
            writeln!(c, "        check_thresholds();").unwrap();
        }
        writeln!(c, "        usleep({interval} * 1000);").unwrap();
        writeln!(c, "    }}").unwrap();
    }

    writeln!(c, "    return 0;").unwrap();
    writeln!(c, "}}").unwrap();
}
