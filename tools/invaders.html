<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>invaders — el-stupido WASM</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#1a1a2e;color:#e0e0e0;font:16px/1.6 monospace;display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh}
canvas{border:2px solid #e94560;border-radius:4px}
#hud{margin:12px 0;font-size:20px}
#msg{color:#e94560;font-size:14px;margin-top:8px}
h1{color:#e94560;margin-bottom:8px;font-size:24px}
.sub{color:#555;font-size:12px;margin-bottom:12px}
</style></head><body>
<h1>invaders</h1>
<div class="sub">written in el-stupido, compiled to WASM, rendered with WebGL</div>
<div id="hud">score: <span id="sc">0</span></div>
<canvas id="c" width="500" height="500"></canvas>
<div id="msg">← → to move — space to shoot</div>
<script>
const GW=20,GH=20,CS=500;
const cv=document.getElementById('c'),gl=cv.getContext('webgl');
if(!gl){document.getElementById('msg').textContent='WebGL not supported';throw'no webgl'}

const vs=`attribute vec2 a;uniform vec4 u;void main(){vec2 p=a*u.zw+u.xy;gl_Position=vec4(p*2.0-1.0,0,1);}`;
const fs=`precision mediump float;uniform vec3 c;void main(){gl_FragColor=vec4(c,1.0);}`;
function mksh(t,s){const sh=gl.createShader(t);gl.shaderSource(sh,s);gl.compileShader(sh);return sh}
const pg=gl.createProgram();
gl.attachShader(pg,mksh(gl.VERTEX_SHADER,vs));
gl.attachShader(pg,mksh(gl.FRAGMENT_SHADER,fs));
gl.linkProgram(pg);gl.useProgram(pg);
const aL=gl.getAttribLocation(pg,'a'),uL=gl.getUniformLocation(pg,'u'),cL=gl.getUniformLocation(pg,'c');
const vb=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vb);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,1,1]),gl.STATIC_DRAW);
gl.enableVertexAttribArray(aL);gl.vertexAttribPointer(aL,2,gl.FLOAT,false,0,0);

const gap=0.04;

const imports={env:{
  gl_clear(r,g,b){gl.clearColor(r/255,g/255,b/255,1);gl.clear(gl.COLOR_BUFFER_BIT)},
  gl_rect(x,y,w,h,r,g,b){
    const cx=x/GW+gap/(2*GW), cy=1-(y+h)/GH+gap/(2*GH);
    const cw=w/GW-gap/GW, ch=h/GH-gap/GH;
    gl.uniform4f(uL,cx,cy,cw,ch);gl.uniform3f(cL,r/255,g/255,b/255);
    gl.drawArrays(gl.TRIANGLE_STRIP,0,4)
  },
  js_random(){return(Math.random()*2147483647)|0}
}};

let wasm,speed=100,timer=null;
let keys={left:false,right:false,fire:false};

function gameLoop(){
  let dir=0;
  if(keys.left)dir=-1;
  else if(keys.right)dir=1;
  let fire=keys.fire?1:0;
  keys.fire=false;
  wasm.set_input(dir,fire);
  wasm.tick();
  render();
}

async function start(){
  const r=await fetch('/invaders.wasm');
  const{instance}=await WebAssembly.instantiate(await r.arrayBuffer(),imports);
  wasm=instance.exports;
  wasm.init();
  render();
  timer=setInterval(gameLoop,speed);
}

function render(){
  wasm.render();
  document.getElementById('sc').textContent=wasm.get_score();
  if(wasm.is_win()){
    clearInterval(timer);timer=null;
    document.getElementById('msg').textContent='YOU WIN — enter to restart'
  }else if(wasm.is_over()){
    clearInterval(timer);timer=null;
    document.getElementById('msg').textContent='GAME OVER — enter to restart'
  }
}

document.addEventListener('keydown',e=>{
  if(!wasm)return;
  if(e.key==='ArrowLeft'){keys.left=true;e.preventDefault()}
  else if(e.key==='ArrowRight'){keys.right=true;e.preventDefault()}
  else if(e.key===' '){keys.fire=true;e.preventDefault()}
  else if(e.key==='Enter'&&(wasm.is_over()||wasm.is_win())){
    e.preventDefault();
    wasm.restart();render();
    if(!timer)timer=setInterval(gameLoop,speed);
    document.getElementById('msg').textContent='← → to move — space to shoot'
  }
});

document.addEventListener('keyup',e=>{
  if(e.key==='ArrowLeft')keys.left=false;
  else if(e.key==='ArrowRight')keys.right=false;
});

start();
</script></body></html>
